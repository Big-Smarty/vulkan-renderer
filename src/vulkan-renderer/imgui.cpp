#include "inexor/vulkan-renderer/imgui.hpp"

#include "inexor/vulkan-renderer/render-graph/graphics_pass_builder.hpp"
#include "inexor/vulkan-renderer/render-graph/pipeline_builder.hpp"
#include "inexor/vulkan-renderer/render-graph/render_graph.hpp"
#include "inexor/vulkan-renderer/wrapper/make_info.hpp"
#include "inexor/vulkan-renderer/wrapper/shader.hpp"

#include <cassert>
#include <stdexcept>
#include <utility>

namespace inexor::vulkan_renderer {

ImGuiOverlay::ImGuiOverlay(const wrapper::Device &device, render_graph::RenderGraph &render_graph,
                           const std::weak_ptr<render_graph::Texture> back_buffer,
                           const std::weak_ptr<render_graph::Texture> depth_buffer,
                           std::function<void()> on_update_user_data)
    : m_device(device), m_vertex_shader(m_device, VK_SHADER_STAGE_VERTEX_BIT, "ImGui", "shaders/ui.vert.spv"),
      m_fragment_shader(m_device, VK_SHADER_STAGE_FRAGMENT_BIT, "ImGui", "shaders/ui.frag.spv"),
      m_on_update_user_data(std::move(on_update_user_data)) {

    spdlog::trace("Creating ImGui context");
    ImGui::CreateContext();

    spdlog::trace("Loading ImGui font texture");
    load_font_data_from_file();

    spdlog::trace("Setting ImGui style");
    set_imgui_style();

    // TODO: Do we need this here?
    using render_graph::BufferType;

    m_vertex_buffer = render_graph.add_buffer("ImGui", BufferType::VERTEX_BUFFER, [&]() {
        // Update the user ImGui data
        m_on_update_user_data();

        const ImDrawData *draw_data = ImGui::GetDrawData();
        if (draw_data == nullptr || draw_data->TotalIdxCount == 0 || draw_data->TotalVtxCount == 0) {
            // Prevent reading from nullpointer and creating buffers of size 0, because both would throw an
            // exception
            return;
        }

        m_index_data.clear();
        m_vertex_data.clear();

        // We need to collect the vertices and indices generated by ImGui
        // because it does not store them in one array, but rather in chunks (command lists)
        for (std::size_t i = 0; i < draw_data->CmdListsCount; i++) {
            const ImDrawList *cmd_list = draw_data->CmdLists[i]; // NOLINT
            for (std::size_t j = 0; j < cmd_list->IdxBuffer.Size; j++) {
                m_index_data.push_back(cmd_list->IdxBuffer.Data[j]); // NOLINT
            }
            for (std::size_t j = 0; j < cmd_list->VtxBuffer.Size; j++) {
                m_vertex_data.push_back(cmd_list->VtxBuffer.Data[j]); // NOLINT
            }
        }
        // Update ImGui vertices and indices
        // Note that the index buffer does not have a separate update code, as it is updated here with vertices
        m_vertex_buffer.lock()->request_update(&m_vertex_data, sizeof(m_vertex_data));
        m_index_buffer.lock()->request_update(&m_index_data, sizeof(m_index_data));
    });

    // Note that the index buffer is updated together with the vertex buffer to keep data consistent
    // This means there is no update lambda here

    // TODO: FIX ME!
    m_index_buffer = render_graph.add_buffer("ImGui", BufferType::INDEX_BUFFER, [] {});

    render_graph.add_graphics_pipeline(
        [&](wrapper::pipelines::GraphicsPipelineBuilder &builder, const VkPipelineLayout pipeline_layout) {
            m_imgui_pipeline = builder
                                   .add_color_blend_attachment({
                                       // TODO: Which values here are by default? (compare with application.cpp)
                                       .blendEnable = VK_TRUE,
                                       .srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA,
                                       .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
                                       .colorBlendOp = VK_BLEND_OP_ADD,
                                       .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
                                       .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO,
                                       .alphaBlendOp = VK_BLEND_OP_ADD,
                                       .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |
                                                         VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT,
                                   })
                                   .set_vertex_input_bindings({
                                       {
                                           .binding = 0,
                                           .stride = sizeof(ImDrawVert),
                                           .inputRate = VK_VERTEX_INPUT_RATE_VERTEX,
                                       },
                                   })
                                   .set_vertex_input_attributes({
                                       {
                                           .location = 0,
                                           .format = VK_FORMAT_R32G32_SFLOAT,
                                           .offset = offsetof(ImDrawVert, pos),
                                       },
                                       {
                                           .location = 1,
                                           .format = VK_FORMAT_R32G32_SFLOAT,
                                           .offset = offsetof(ImDrawVert, uv),
                                       },
                                       {
                                           .location = 2,
                                           .format = VK_FORMAT_R8G8B8A8_UNORM,
                                           .offset = offsetof(ImDrawVert, col),
                                       },
                                   })
                                   .add_shader(m_vertex_shader)
                                   .add_shader(m_fragment_shader)
                                   .set_pipeline_layout(pipeline_layout)
                                   .build("ImGui");
            return m_imgui_pipeline;
        });

    m_imgui_texture = render_graph.add_texture("ImGui font",                       //
                                               render_graph::TextureUsage::NORMAL, //
                                               VK_FORMAT_R8G8B8A8_UNORM,           //
                                               [&]() {
                                                   // Initialize the font texture
                                                   m_imgui_texture.lock()->request_update(m_font_texture_data,
                                                                                          m_font_texture_data_size);
                                               });

    render_graph.add_graphics_pass([&](render_graph::GraphicsPassBuilder &builder) {
        m_imgui_pass = builder.reads_from_buffer(m_index_buffer)
                           .reads_from_buffer(m_vertex_buffer)
                           .reads_from_texture(m_imgui_texture, VK_SHADER_STAGE_FRAGMENT_BIT)
                           .writes_to_texture(back_buffer)
                           .writes_to_texture(depth_buffer)
                           .writes_to_texture(back_buffer)
                           .writes_to_texture(depth_buffer)
                           .add_push_constant_range(VK_SHADER_STAGE_VERTEX_BIT, &m_push_const_block,
                                                    [&]() {
                                                        // Update lambda for ImGui push constant range
                                                        const ImGuiIO &io = ImGui::GetIO();
                                                        m_push_const_block.scale =
                                                            glm::vec2(2.0f / io.DisplaySize.x, 2.0f / io.DisplaySize.y);
                                                    })
                           .set_on_record([&](const wrapper::CommandBuffer &cmd_buf) {
                               cmd_buf.bind_pipeline(*m_imgui_pipeline);
                               ImDrawData *draw_data = ImGui::GetDrawData();
                               if (draw_data == nullptr) {
                                   return;
                               }
                               std::uint32_t index_offset = 0;
                               std::int32_t vertex_offset = 0;
                               for (std::size_t i = 0; i < draw_data->CmdListsCount; i++) {
                                   const ImDrawList *cmd_list = draw_data->CmdLists[i]; // NOLINT
                                   for (std::int32_t j = 0; j < cmd_list->CmdBuffer.Size; j++) {
                                       const ImDrawCmd &draw_cmd = cmd_list->CmdBuffer[j];
                                       cmd_buf.draw_indexed(draw_cmd.ElemCount, 1, index_offset, vertex_offset);
                                       index_offset += draw_cmd.ElemCount;
                                   }
                                   vertex_offset += cmd_list->VtxBuffer.Size;
                               }
                           })
                           .build("ImGui");
        return m_imgui_pass;
    });
}

ImGuiOverlay::~ImGuiOverlay() {
    ImGui::DestroyContext();
}

void ImGuiOverlay::load_font_data_from_file() {
    ImGuiIO &io = ImGui::GetIO();
    io.FontGlobalScale = 1.0f;

    // This is here because it doesn't need to be member data
    constexpr const char *FONT_FILE_PATH = "assets/fonts/NotoSans-Bold.ttf";
    constexpr float FONT_SIZE = 18.0f;

    spdlog::trace("Loading front {} with size {}", FONT_FILE_PATH, FONT_SIZE);
    ImFont *font = io.Fonts->AddFontFromFileTTF(FONT_FILE_PATH, FONT_SIZE);
    io.Fonts->GetTexDataAsRGBA32(&m_font_texture_data, &m_font_texture_width, &m_font_texture_height);

    constexpr int FONT_TEXTURE_CHANNELS = 4;
    m_font_texture_data_size = m_font_texture_width * m_font_texture_height * FONT_TEXTURE_CHANNELS;
}

void ImGuiOverlay::set_imgui_style() {
    ImGuiStyle &style = ImGui::GetStyle();
    style.Colors[ImGuiCol_TitleBg] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
    style.Colors[ImGuiCol_TitleBgActive] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
    style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.0f, 0.0f, 0.0f, 0.1f);
    style.Colors[ImGuiCol_MenuBarBg] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_Header] = ImVec4(0.8f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_HeaderActive] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_HeaderHovered] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_FrameBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.8f);
    style.Colors[ImGuiCol_CheckMark] = ImVec4(1.0f, 0.0f, 0.0f, 0.8f);
    style.Colors[ImGuiCol_SliderGrab] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(1.0f, 0.0f, 0.0f, 0.8f);
    style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(1.0f, 1.0f, 1.0f, 0.1f);
    style.Colors[ImGuiCol_FrameBgActive] = ImVec4(1.0f, 1.0f, 1.0f, 0.2f);
    style.Colors[ImGuiCol_Button] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_ButtonHovered] = ImVec4(1.0f, 0.0f, 0.0f, 0.6f);
    style.Colors[ImGuiCol_ButtonActive] = ImVec4(1.0f, 0.0f, 0.0f, 0.8f);
}

} // namespace inexor::vulkan_renderer
