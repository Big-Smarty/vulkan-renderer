#include "inexor/vulkan-renderer/renderers/imgui.hpp"

#include "inexor/vulkan-renderer/render-graph/graphics_pass_builder.hpp"
#include "inexor/vulkan-renderer/render-graph/render_graph.hpp"
#include "inexor/vulkan-renderer/wrapper/make_info.hpp"
#include "inexor/vulkan-renderer/wrapper/shader.hpp"
#include "inexor/vulkan-renderer/wrapper/swapchain.hpp"

#include <cassert>
#include <stdexcept>
#include <utility>

namespace inexor::vulkan_renderer::renderers {

ImGuiRenderer::ImGuiRenderer(const Device &device,
                             std::weak_ptr<RenderGraph> render_graph,
                             std::weak_ptr<GraphicsPass> previous_pass,
                             std::weak_ptr<Swapchain> swapchain,
                             std::function<void()> on_update_user_data)
    : m_on_update_user_data(std::move(on_update_user_data)), m_previous_pass(std::move(previous_pass)),
      m_swapchain(std::move(swapchain)) /*, m_color_attachment(std::move(color_attachment))*/ {

    if (render_graph.expired()) {
        throw std::invalid_argument(
            "[ImGuiRenderer::ImGuiRenderer] Error: Parameter 'render_graph' is an invalid pointer!");
    }
    if (m_swapchain.expired()) {
        throw std::invalid_argument(
            "[ImGuiRenderer::ImGuiRenderer] Error: Parameter 'm_swapchain' is an invalid pointer!");
    }
    // NOTE: It's valid for previous_pass to be an invalid pointer (in that case there is no previous pass!)

    spdlog::trace("Creating ImGui context");
    ImGui::CreateContext();

    spdlog::trace("Loading ImGui font texture");
    load_font_data_from_file();

    spdlog::trace("Setting ImGui style");
    set_imgui_style();

    auto graph = render_graph.lock();
    auto target_swapchain = m_swapchain.lock();

    using render_graph::BufferType;
    m_vertex_buffer = graph->add_buffer("ImGui|Vertex", BufferType::VERTEX_BUFFER, [&]() {
        m_on_update_user_data();
        const ImDrawData *draw_data = ImGui::GetDrawData();

        m_index_data.clear();
        m_vertex_data.clear();
        // We need to collect the vertices and indices generated by ImGui
        // because it does not store them in one array, but rather in chunks (command lists)
        for (std::size_t i = 0; i < draw_data->CmdListsCount; i++) {
            const ImDrawList *cmd_list = draw_data->CmdLists[i]; // NOLINT
            for (std::size_t j = 0; j < cmd_list->IdxBuffer.Size; j++) {
                m_index_data.push_back(cmd_list->IdxBuffer.Data[j]); // NOLINT
            }
            for (std::size_t j = 0; j < cmd_list->VtxBuffer.Size; j++) {
                m_vertex_data.push_back(cmd_list->VtxBuffer.Data[j]); // NOLINT
            }
        }
        if (m_vertex_data.size() > 0) {
            // Request rendergraph to do an update of the vertex buffer
            m_vertex_buffer.lock()->request_update(m_vertex_data);
        }
    });

    m_index_buffer = graph->add_buffer("ImGui|Index", BufferType::INDEX_BUFFER, [&]() {
        if (m_index_data.size() > 0) {
            // Request rendergraph to do an update of the index buffer
            m_index_buffer.lock()->request_update(m_index_data);
        }
    });

    m_vertex_shader =
        std::make_shared<wrapper::Shader>(device, "ImGui", VK_SHADER_STAGE_VERTEX_BIT, "shaders/ui.vert.spv");
    m_fragment_shader =
        std::make_shared<wrapper::Shader>(device, "ImGui", VK_SHADER_STAGE_FRAGMENT_BIT, "shaders/ui.frag.spv");

    m_imgui_texture = graph->add_texture("ImGui-Font", render_graph::TextureUsage::NORMAL, VK_FORMAT_R8G8B8A8_UNORM,
                                         m_font_texture_width, m_font_texture_width, VK_SAMPLE_COUNT_1_BIT, [&]() {
                                             // Initialize the ImGui font texture only once in the update function
                                             if (!m_font_texture_initialized) {
                                                 m_imgui_texture.lock()->request_update(m_font_texture_data,
                                                                                        m_font_texture_data_size);
                                                 m_font_texture_initialized = true;
                                             }
                                         });

    graph->add_resource_descriptor(
        [&](wrapper::descriptors::DescriptorSetLayoutBuilder &builder) {
            m_descriptor_set_layout = builder.add_combined_image_sampler(VK_SHADER_STAGE_FRAGMENT_BIT).build("ImGui");
        },
        [&](wrapper::descriptors::DescriptorSetAllocator &allocator) {
            m_descriptor_set = allocator.allocate("ImGui", m_descriptor_set_layout);
        },
        [&](wrapper::descriptors::WriteDescriptorSetBuilder &builder) -> std::vector<VkWriteDescriptorSet> {
            return builder.add_combined_image_sampler_update(m_descriptor_set, m_imgui_texture).build();
        });

    graph->add_graphics_pipeline([&](wrapper::pipelines::GraphicsPipelineBuilder &builder) {
        m_imgui_pipeline = builder
                               .set_vertex_input_bindings({
                                   {
                                       .binding = 0,
                                       .stride = sizeof(ImDrawVert),
                                       .inputRate = VK_VERTEX_INPUT_RATE_VERTEX,
                                   },
                               })
                               .set_vertex_input_attributes({
                                   {
                                       .location = 0,
                                       .format = VK_FORMAT_R32G32_SFLOAT,
                                       .offset = offsetof(ImDrawVert, pos),
                                   },
                                   {
                                       .location = 1,
                                       .format = VK_FORMAT_R32G32_SFLOAT,
                                       .offset = offsetof(ImDrawVert, uv),
                                   },
                                   {
                                       .location = 2,
                                       .format = VK_FORMAT_R8G8B8A8_UNORM,
                                       .offset = offsetof(ImDrawVert, col),
                                   },
                               })
                               .add_color_blend_attachment({
                                   .blendEnable = VK_TRUE,
                                   .srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA,
                                   .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
                                   .colorBlendOp = VK_BLEND_OP_ADD,
                                   .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
                                   .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO,
                                   .alphaBlendOp = VK_BLEND_OP_ADD,
                               })
                               .add_color_attachment_format(m_swapchain.lock()->image_format())
                               .set_viewport(m_swapchain.lock()->extent())
                               .set_scissor(m_swapchain.lock()->extent())
                               .add_shader(m_vertex_shader)
                               .add_shader(m_fragment_shader)
                               .set_descriptor_set_layout(m_descriptor_set_layout)
                               .add_push_constant_range(VK_SHADER_STAGE_VERTEX_BIT, sizeof(m_push_const_block))
                               .build("ImGui");
        return m_imgui_pipeline;
    });

    graph->add_graphics_pass([&](render_graph::GraphicsPassBuilder &builder) {
        // NOTE: ImGui does not write to depth buffer and it reads from octree pass (previous pass)
        // NOTE: We directly return the ImGui graphics pass and do not store it in here because it's the last pass (for
        // now) and there is no reads_from function which would need it.
        return builder.writes_to(m_swapchain)
            .conditionally_reads_from(m_previous_pass, !m_previous_pass.expired())
            .set_on_record([&](const wrapper::commands::CommandBuffer &cmd_buf) {
                ImDrawData *draw_data = ImGui::GetDrawData();
                if (draw_data == nullptr || draw_data->TotalIdxCount == 0 || draw_data->TotalVtxCount == 0) {
                    m_on_update_user_data();
                    return;
                }
                const ImGuiIO &io = ImGui::GetIO();
                m_push_const_block.scale = glm::vec2(2.0f / io.DisplaySize.x, 2.0f / io.DisplaySize.y);

                cmd_buf.bind_pipeline(m_imgui_pipeline)
                    .bind_vertex_buffer(m_vertex_buffer)
                    .bind_index_buffer(m_index_buffer)
                    .bind_descriptor_set(m_descriptor_set, m_imgui_pipeline)
                    .push_constant(m_imgui_pipeline, m_push_const_block, VK_SHADER_STAGE_VERTEX_BIT);

                // TODO: Crop to ImGui viewport and scissor for improved performance

                std::uint32_t index_offset = 0;
                std::int32_t vertex_offset = 0;
                for (std::size_t i = 0; i < draw_data->CmdListsCount; i++) {
                    const ImDrawList *cmd_list = draw_data->CmdLists[i];
                    for (std::int32_t j = 0; j < cmd_list->CmdBuffer.Size; j++) {
                        const ImDrawCmd &draw_cmd = cmd_list->CmdBuffer[j];
                        cmd_buf.draw_indexed(draw_cmd.ElemCount, 1, index_offset, vertex_offset);
                        index_offset += draw_cmd.ElemCount;
                    }
                    vertex_offset += cmd_list->VtxBuffer.Size;
                }
            })
            .build("ImGui", render_graph::DebugLabelColor::BLUE);
    });
}

ImGuiRenderer::ImGuiRenderer(ImGuiRenderer &&other) noexcept {
    // TODO: Implement me!
}

ImGuiRenderer::~ImGuiRenderer() {
    ImGui::DestroyContext();
}

void ImGuiRenderer::load_font_data_from_file() {
    ImGuiIO &io = ImGui::GetIO();
    io.FontGlobalScale = 1.0f;

    // This is here because it doesn't need to be member data
    constexpr const char *FONT_FILE_PATH = "assets/fonts/NotoSans-Bold.ttf";
    constexpr float FONT_SIZE = 18.0f;

    spdlog::trace("Loading front {} with size {}", FONT_FILE_PATH, FONT_SIZE);
    ImFont *font = io.Fonts->AddFontFromFileTTF(FONT_FILE_PATH, FONT_SIZE);
    io.Fonts->GetTexDataAsRGBA32(&m_font_texture_data, &m_font_texture_width, &m_font_texture_height);

    constexpr int FONT_TEXTURE_CHANNELS = 4;
    m_font_texture_data_size = m_font_texture_width * m_font_texture_height * FONT_TEXTURE_CHANNELS;
}

void ImGuiRenderer::set_imgui_style() {
    ImGuiStyle &style = ImGui::GetStyle();
    style.Colors[ImGuiCol_TitleBg] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
    style.Colors[ImGuiCol_TitleBgActive] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
    style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.0f, 0.0f, 0.0f, 0.1f);
    style.Colors[ImGuiCol_MenuBarBg] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_Header] = ImVec4(0.8f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_HeaderActive] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_HeaderHovered] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_FrameBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.8f);
    style.Colors[ImGuiCol_CheckMark] = ImVec4(1.0f, 0.0f, 0.0f, 0.8f);
    style.Colors[ImGuiCol_SliderGrab] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(1.0f, 0.0f, 0.0f, 0.8f);
    style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(1.0f, 1.0f, 1.0f, 0.1f);
    style.Colors[ImGuiCol_FrameBgActive] = ImVec4(1.0f, 1.0f, 1.0f, 0.2f);
    style.Colors[ImGuiCol_Button] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_ButtonHovered] = ImVec4(1.0f, 0.0f, 0.0f, 0.6f);
    style.Colors[ImGuiCol_ButtonActive] = ImVec4(1.0f, 0.0f, 0.0f, 0.8f);
}

} // namespace inexor::vulkan_renderer::renderers
