#include "inexor/vulkan-renderer/renderers/imgui.hpp"

#include "inexor/vulkan-renderer/render-graph/graphics_pass_builder.hpp"
#include "inexor/vulkan-renderer/render-graph/render_graph.hpp"
#include "inexor/vulkan-renderer/wrapper/make_info.hpp"
#include "inexor/vulkan-renderer/wrapper/shader.hpp"
#include "inexor/vulkan-renderer/wrapper/swapchain.hpp"

#include <cassert>
#include <stdexcept>
#include <utility>

namespace inexor::vulkan_renderer::renderers {

ImGuiRenderer::ImGuiRenderer(const Device &device,
                             const Swapchain &swapchain,
                             render_graph::RenderGraph &render_graph,
                             std::weak_ptr<render_graph::Texture> color_attachment,
                             std::function<void()> on_update_user_data)
    : m_device(device), m_on_update_user_data(std::move(on_update_user_data)),
      m_color_attachment(std::move(color_attachment)) {

    spdlog::trace("Creating ImGui context");
    ImGui::CreateContext();

    spdlog::trace("Loading ImGui font texture");
    load_font_data_from_file();

    spdlog::trace("Setting ImGui style");
    set_imgui_style();

    // TODO: Do we need this here?
    using render_graph::BufferType;

    // TODO: Do we really need vert_input_attr_descs here?
    m_vertex_buffer = render_graph.add_buffer("ImGui", BufferType::VERTEX_BUFFER, [&]() {
        m_on_update_user_data();
        const ImDrawData *draw_data = ImGui::GetDrawData();
        if (draw_data == nullptr || draw_data->TotalIdxCount == 0 || draw_data->TotalVtxCount == 0) {
            return;
        }
        m_index_data.clear();
        m_vertex_data.clear();
        // We need to collect the vertices and indices generated by ImGui
        // because it does not store them in one array, but rather in chunks (command lists)
        for (std::size_t i = 0; i < draw_data->CmdListsCount; i++) {
            const ImDrawList *cmd_list = draw_data->CmdLists[i]; // NOLINT
            for (std::size_t j = 0; j < cmd_list->IdxBuffer.Size; j++) {
                m_index_data.push_back(cmd_list->IdxBuffer.Data[j]); // NOLINT
            }
            for (std::size_t j = 0; j < cmd_list->VtxBuffer.Size; j++) {
                m_vertex_data.push_back(cmd_list->VtxBuffer.Data[j]); // NOLINT
            }
        }
        // NOTE: The index buffer does not have a separate update code because it is updated here with the vertices
        m_vertex_buffer->request_update(m_vertex_data);
        m_index_buffer->request_update(m_index_data);
    });

    m_index_buffer = render_graph.add_buffer("ImGui", BufferType::INDEX_BUFFER, [&]() {
        // Index buffer is already being updated in vertex buffer update lambda...
    });

    // TODO: Implement a ShaderManager (ShaderCache?) inside of Device wrapper?
    m_vertex_shader =
        std::make_shared<wrapper::Shader>(m_device, "ImGui", VK_SHADER_STAGE_VERTEX_BIT, "shaders/ui.vert.spv");
    m_fragment_shader =
        std::make_shared<wrapper::Shader>(m_device, "ImGui", VK_SHADER_STAGE_FRAGMENT_BIT, "shaders/ui.frag.spv");

    using render_graph::TextureUsage;
    m_imgui_texture = render_graph.add_texture("ImGui-Font", TextureUsage::NORMAL, [&]() {
        const auto img_ci = wrapper::make_info<VkImageCreateInfo>({
            .imageType = VK_IMAGE_TYPE_2D,
            .format = VK_FORMAT_R8G8B8A8_UNORM,
            .extent =
                {
                    .width = static_cast<std::uint32_t>(m_font_texture_width),
                    .height = static_cast<std::uint32_t>(m_font_texture_height),
                    .depth = 1,
                },
            .mipLevels = 1,
            .arrayLayers = 1,
            .samples = VK_SAMPLE_COUNT_1_BIT,
            .tiling = VK_IMAGE_TILING_OPTIMAL,
            .usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,
            .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
            .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
        });
        const auto img_view_ci = wrapper::make_info<VkImageViewCreateInfo>({
            .viewType = VK_IMAGE_VIEW_TYPE_2D,
            .format = VK_FORMAT_R8G8B8A8_UNORM,
            .subresourceRange =
                {
                    .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
                    .baseMipLevel = 0,
                    .levelCount = 1,
                    .baseArrayLayer = 0,
                    .layerCount = 1,
                },
        });
        m_imgui_texture->request_update(m_font_texture_data, m_font_texture_data_size, img_ci, img_view_ci);
    });

    using wrapper::descriptors::DescriptorSetAllocator;
    using wrapper::descriptors::DescriptorSetLayoutBuilder;
    using wrapper::descriptors::DescriptorSetUpdateBuilder;
    using wrapper::pipelines::GraphicsPipelineBuilder;

    render_graph.add_resource_descriptor(
        [&](DescriptorSetLayoutBuilder &descriptor_set_layout_builder) {
            m_descriptor_set_layout =
                descriptor_set_layout_builder.add_combined_image_sampler(VK_SHADER_STAGE_FRAGMENT_BIT).build("ImGui");
        },
        [&](DescriptorSetAllocator &descriptor_set_allocator) {
            m_descriptor_set = descriptor_set_allocator.allocate(m_descriptor_set_layout);
        },
        [&](DescriptorSetUpdateBuilder &descriptor_set_update_builder) {
            descriptor_set_update_builder.add_combined_image_sampler_update(m_descriptor_set, m_imgui_texture).update();
        });

    render_graph.add_graphics_pipeline([&](GraphicsPipelineBuilder &graphics_pipeline_builder) {
        m_imgui_pipeline = graphics_pipeline_builder
                               .set_vertex_input_bindings({
                                   {
                                       .binding = 0,
                                       .stride = sizeof(ImDrawVert),
                                       .inputRate = VK_VERTEX_INPUT_RATE_VERTEX,
                                   },
                               })
                               .set_vertex_input_attributes({
                                   {
                                       .location = 0,
                                       .format = VK_FORMAT_R32G32_SFLOAT,
                                       .offset = offsetof(ImDrawVert, pos),
                                   },
                                   {
                                       .location = 1,
                                       .format = VK_FORMAT_R32G32_SFLOAT,
                                       .offset = offsetof(ImDrawVert, uv),
                                   },
                                   {
                                       .location = 2,
                                       .format = VK_FORMAT_R8G8B8A8_UNORM,
                                       .offset = offsetof(ImDrawVert, col),
                                   },
                               })
                               .add_default_color_blend_attachment()
                               .add_color_attachment(swapchain.image_format())
                               .set_depth_attachment_format(VK_FORMAT_D32_SFLOAT_S8_UINT)
                               .set_viewport(swapchain.extent())
                               .set_scissor(swapchain.extent())
                               .uses_shader(m_vertex_shader)
                               .uses_shader(m_fragment_shader)
                               .set_descriptor_set_layout(m_descriptor_set_layout)
                               .add_push_constant_range(VK_SHADER_STAGE_VERTEX_BIT, sizeof(m_push_const_block))
                               .build("ImGui");
        return m_imgui_pipeline;
    });

    using render_graph::GraphicsPassBuilder;
    using wrapper::commands::CommandBuffer;
    render_graph.add_graphics_pass([&](GraphicsPassBuilder &graphics_pass_builder) {
        m_imgui_pass = graphics_pass_builder.add_color_attachment(m_color_attachment)
                           .set_on_record([&](const CommandBuffer &cmd_buf) {
                               // NOTE: It's the responsibility of the programmer to bind pipelines, descriptor sets,
                               // and buffers manually inside of this on_record lambda! It's also the responsibility of
                               // the programmer to make sure that every variable captured by reference inside of this
                               // lambda is still in a valid state at the time of execution of the lambda!
                               const ImGuiIO &io = ImGui::GetIO();
                               m_push_const_block.scale = glm::vec2(2.0f / io.DisplaySize.x, 2.0f / io.DisplaySize.y);

                               cmd_buf.bind_pipeline(m_imgui_pipeline)
                                   .bind_vertex_buffer(m_vertex_buffer)
                                   .bind_index_buffer(m_index_buffer)
                                   .bind_descriptor_set(m_descriptor_set, m_imgui_pipeline)
                                   .push_constant(m_imgui_pipeline, m_push_const_block, VK_SHADER_STAGE_VERTEX_BIT);

                               ImDrawData *draw_data = ImGui::GetDrawData();
                               if (draw_data == nullptr) {
                                   return;
                               }
                               std::uint32_t index_offset = 0;
                               std::int32_t vertex_offset = 0;
                               for (std::size_t i = 0; i < draw_data->CmdListsCount; i++) {
                                   const ImDrawList *cmd_list = draw_data->CmdLists[i];
                                   for (std::int32_t j = 0; j < cmd_list->CmdBuffer.Size; j++) {
                                       const ImDrawCmd &draw_cmd = cmd_list->CmdBuffer[j];
                                       cmd_buf.draw_indexed(draw_cmd.ElemCount, 1, index_offset, vertex_offset);
                                       index_offset += draw_cmd.ElemCount;
                                   }
                                   vertex_offset += cmd_list->VtxBuffer.Size;
                               }
                           })
                           .build("ImGui");
        return m_imgui_pass;
    });
}

ImGuiRenderer::~ImGuiRenderer() {
    ImGui::DestroyContext();
}

void ImGuiRenderer::load_font_data_from_file() {
    ImGuiIO &io = ImGui::GetIO();
    io.FontGlobalScale = 1.0f;

    // This is here because it doesn't need to be member data
    constexpr const char *FONT_FILE_PATH = "assets/fonts/NotoSans-Bold.ttf";
    constexpr float FONT_SIZE = 18.0f;

    spdlog::trace("Loading front {} with size {}", FONT_FILE_PATH, FONT_SIZE);
    ImFont *font = io.Fonts->AddFontFromFileTTF(FONT_FILE_PATH, FONT_SIZE);
    io.Fonts->GetTexDataAsRGBA32(&m_font_texture_data, &m_font_texture_width, &m_font_texture_height);

    constexpr int FONT_TEXTURE_CHANNELS = 4;
    m_font_texture_data_size = m_font_texture_width * m_font_texture_height * FONT_TEXTURE_CHANNELS;
}

void ImGuiRenderer::set_imgui_style() {
    ImGuiStyle &style = ImGui::GetStyle();
    style.Colors[ImGuiCol_TitleBg] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
    style.Colors[ImGuiCol_TitleBgActive] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
    style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.0f, 0.0f, 0.0f, 0.1f);
    style.Colors[ImGuiCol_MenuBarBg] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_Header] = ImVec4(0.8f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_HeaderActive] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_HeaderHovered] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_FrameBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.8f);
    style.Colors[ImGuiCol_CheckMark] = ImVec4(1.0f, 0.0f, 0.0f, 0.8f);
    style.Colors[ImGuiCol_SliderGrab] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(1.0f, 0.0f, 0.0f, 0.8f);
    style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(1.0f, 1.0f, 1.0f, 0.1f);
    style.Colors[ImGuiCol_FrameBgActive] = ImVec4(1.0f, 1.0f, 1.0f, 0.2f);
    style.Colors[ImGuiCol_Button] = ImVec4(1.0f, 0.0f, 0.0f, 0.4f);
    style.Colors[ImGuiCol_ButtonHovered] = ImVec4(1.0f, 0.0f, 0.0f, 0.6f);
    style.Colors[ImGuiCol_ButtonActive] = ImVec4(1.0f, 0.0f, 0.0f, 0.8f);
}

} // namespace inexor::vulkan_renderer::renderers
